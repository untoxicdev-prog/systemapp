# Project Workflow (SSOT): Vibe-coding + AI Assistant

**Назначение:** единый источник правды о том, *как* мы разрабатываем веб‑приложение (не о бизнес‑логике конкретного проекта).  
**Ключевая нить:** **продукт → требования → архитектура → задачи → код → проверка → деплой**.

> **Правило №1 (итерации):** не “сделай всё приложение”. Делаем **короткие проверяемые шаги**: “после шага я могу запустить X и увидеть Y”.

> **Правило №2 (SOTA-критерий):** решения, роли, методы и результаты должны быть **state‑of‑the‑art на текущую дату** (best practices индустрии), а не “как попроще/как привыкли”.
>
> **Операционализация SOTA:**
> - **Версионируем и проверяем**: фиксируем версии стека/инструментов; делаем проверяемые шаги (тесты/линтер/типизация/CI) вместо “на глаз”.
> - **Предпочитаем мейнстрим‑практики**: широко используемые, поддерживаемые, с хорошими доками и экосистемой.
> - **Нет bleeding-edge без причины**: экспериментальные технологии — только с явной выгодой и планом отката.
> - **Сомневаемся → сверяемся с источниками**: официальные доки/релизы/гайдлайны; фиксируем вывод в Decision log (см. §3).

---

## 0. Как ссылаться на этот документ

- **Ссылки**: указываем заголовок (`##` / `###`) и, при необходимости, ключевую фразу в кавычках.  
  Пример: “см. **§2.2 Agent — делаем изменения**, фраза ‘реальные изменения в проекте’”.
- **Параграфы**: если есть номер вида **§2.5 / §2.3.1**, ссылаемся на него + ключевую фразу.  
  Пример: “см. **§2.5**, пункт ‘**Fallback**’”.
- **Изменения процесса**: любые новые правила/ритуалы добавляем сюда сразу (см. §5).

---

## 1. Постановка задачи: от абстракции к коду

**Двигаемся слоями.** По завершении слоя фиксируем артефакт (в чате и/или в репо).

### 1.1 Слой A — продукт
- **Описание**: что за приложение, кто пользователь, ценность (1–2 абзаца).
- **User stories**: 3–7 историй в формате “как \<роль> хочу \<действие>, чтобы \<ценность>”.
- **MVP границы**: что входит / что явно не входит в v1.

### 1.2 Слой B — требования
- **Функциональные**: список фич (по приоритету).
- **Нефункциональные**: скорость, безопасность, SEO, бюджет, сроки, доступность (выбрать релевантное).
- **Данные**: список сущностей (черновые модели/таблицы).

### 1.3 Слой C — UX/UI (Figma → спецификация)
- **Вход**: пачка экранов одного сценария + что является MVP + правила (валидации/роли/ограничения).
- **Выход от ассистента**:
  - декомпозиция **экраны → компоненты**,
  - список состояний **loading / empty / error**,
  - **контракты API** под каждый экран.
- **Формат результата (обязательный)**: таблица  
  **Экран → API → Модели → Компоненты → Edge cases**.

### 1.4 Слой D — архитектура
- **Стек**: варианты + trade-offs.
- **Схема деплоя**: как будет жить в проде (сеть, SSL, секреты, миграции).
- **Контракты**: auth, роли, хранение файлов, миграции, фоновые задачи (если нужно).
- **Артефакт**: “архитектурная карточка” на 1–2 страницы.

### 1.5 Слой E — реализация
- **Backlog**: эпики → задачи, у каждой есть **критерии готовности** (см. `templates/project-controls.md`).
- **Доставка**: код/конфиги → запуск → проверки → деплой.

### 1.6 Этапы проекта (Lite, SOTA) — “тонкая нить” до продакшена

Цель этапов — **как можно раньше** получить работающий контур (CI + smoke‑deploy) и дальше наращивать функциональность без переделок.

- **E0 Inception**: North Star, MVP границы, NFR (безопасность/перф/SEO/бюджет), ключевой сценарий.
- **E1 Architecture (Lite)**: выбрать стек + деплой‑схему; заполнить `templates/architecture-description.md`; зафиксировать решения в `templates/project-controls.md` (раздел “Decision log”).
- **E2 Skeleton + CI + Smoke Deploy**: каркас репо; линт/типизация/тест‑скелет; docker-compose; healthcheck; первый минимальный деплой.
- **E3 Frontend w/ Contract Mocks**: UI по прототипу v0; моки строго по будущим DTO/контрактам.
- **E4 Backend + DB + Migrations**: модели; миграции/сиды; основные эндпоинты.
- **E5 E2E Integration**: сквозной сценарий; empty/loading/error; наблюдаемость (логи/метрики базово).
- **E6 Hardening**: тесты; безопасность; бэкапы/миграции; мониторинг; эксплуатационные чек‑листы.
- **E7 Visual Polish**: финальный дизайн/анимации/пиксель‑перфект.

> Принцип: **деплой начинается рано** (E2), а не “в конце”, чтобы не получить сюрпризы инфраструктуры на финише.

---

## 2. Режимы ассистента: когда какой включать

### 2.1 Plan — “карта местности”
**Когда:** старт проекта и любые “развилки” (стек, auth, деплой, структура БД).  
**Выход:** **план + критерии готовности + риски + чек‑лист проверок**.  
**Триггер:** обсуждаем > 2 альтернатив или появляется “а давай ещё…”.

#### 2.1.1 Роли и компетенции (Plan)
- **Роли:** системный архитектор, аналитик требований, риск‑менеджер, техлид (design review).
- **Делаю:** варианты + trade-offs; декомпозиция на этапы; критерии готовности; риски/миграции; “что проверить”.
- **Не делаю:** не начинаю писать код “в никуда” без согласованных решений; не оптимизирую детали раньше MVP.
- **Компетенции:** архитектурные паттерны, безопасность, DX/CI/CD, эксплуатация, оценка сложности.
- **От тебя нужно:** цель/MVP, ограничения, предпочтения стека/деплоя, допущения “что ок”.

### 2.2 Agent — “делаем изменения”
**Когда:** решение принято и нужно **создавать файлы/код/конфиги**.  
**Выход:** **реальные изменения в проекте** (или точные шаги/диффы, если без прямого доступа).  
**Триггер:** “ок, реализуем”.

#### 2.2.1 Роли и компетенции (Agent)
- **Роли:** full‑stack разработчик, DevOps‑помощник, инженер по интеграции.
- **Делаю:** создаю/меняю файлы; провожу связные изменения; обновляю конфиги; держу единый стиль/структуру; оставляю команды запуска/проверки.
- **Не делаю:** не внедряю крупные изменения без plan‑решения на развилке; не “усложняю ради красоты” (если не SOTA‑обосновано).
- **Компетенции:** код‑генерация, refactor‑практики, типизация, API‑контракты, миграции, Docker/CI, безопасность по умолчанию.
- **От тебя нужно:** критерии готовности шага (что должно заработать), целевой стек, ограничения деплоя.

### 2.3 Debug — “сломалось/непонятно”
**Когда:** ошибки, флейки, проблемы окружения, деплой/инфра “не взлетели”.  
**Процесс:** гипотеза → проверка → причина → фикс → подтверждение.  
**Триггер:** 2 попытки “пофиксить наугад” или причина не очевидна.

#### 2.3.1 Роли и компетенции (Debug)
- **Роли:** инженер по расследованию инцидентов, QA‑аналитик, performance/security triage.
- **Делаю:** формирую гипотезы; предлагаю минимальные проверки; локализую причину; даю фикс + способ подтвердить; снижаю шанс регрессий.
- **Не делаю:** не гадаю без данных; не лечу симптом, если можно найти первопричину.
- **Компетенции:** чтение логов/трейсов, репродукция, изоляция, анализ зависимостей, CI‑отладка.
- **От тебя нужно:** шаги воспроизведения, логи/ошибки, окружение (OS/версии), что менялось последним.

### 2.4 Ask — “консультация и управление”
**Когда:** уточнение требований, ревью решений, объяснения, работа с прототипами, подготовка ТЗ/тасков/чек‑листов.

#### 2.4.1 Роли и компетенции (Ask)
- **Роли:** продукт‑помощник, UX‑аналитик (по скринам), code reviewer, наставник.
- **Делаю:** отвечаю точечно; объясняю решения; делаю ревью; превращаю прототипы в спецификации (см. §1.3, §4).
- **Не делаю:** не обещаю “идеально” без контекста/данных; не подменяю Plan/Debug/Agent, если нужен другой режим.
- **Компетенции:** объяснение trade-offs, чтение UI по скриншотам, формализация требований, подготовка тасков/чек‑листов.
- **От тебя нужно:** вопрос + контекст + желаемый формат выхода (список/таблица/решение/аргументы).

### 2.5 Рекомендации по выбору модели (SOTA)
**Цель:** максимальная эффективность \(качество результата × скорость итераций\) при соблюдении **Правила №2 (SOTA)**.

- **Plan / Debug:** выбирай модель с максимально сильным **reasoning** и стабильным качеством на длинных цепочках (архитектура, trade-offs, расследования).
- **Agent:** выбирай модель, оптимизированную под **код** (часто “Codex/Code”-варианты), с дисциплиной по типам, структуре и рефакторингу.
- **Ask + Figma:** нужна модель с **vision** + хорошее reasoning (UI → API → БД).
- **Ask (простые вопросы):** можно Auto/быструю модель, если цена/скорость важнее “идеальности”.

**Практическая схема (без привязки к брендам):**
- “Код”‑модель → по умолчанию для **Agent**.
- “Reasoning”‑модель → по умолчанию для **Plan/Debug**.
- “Vision”‑модель → по умолчанию для **Figma**.
- **Fallback:** если провайдер недоступен/`resource_exhausted` → переключиться на следующую лучшую модель или `Auto`, но фиксировать компромисс в Decision log (§3).

**Примечание:** если доступны новые SOTA‑модели (например GPT‑5.2 / GPT‑5.2‑Codex / Gemini 3), их стоит предпочитать при условии, что они:
- поддерживают нужную модальность (vision),
- держат контекст,
- стабильно дают качественный код/планы на ваших задачах.

> **Типичный маршрут:** **Plan → Agent**, а **Ask/Debug** — по необходимости.

---

## 3. Контроль хода проекта (чтобы дойти до продакшена)

Держим и регулярно обновляем 4 “якоря”:

1. **North Star**: 1 абзац — что считаем “готовым приложением” (включая деплой).
2. **Backlog**: эпики/задачи, приоритеты, статусы “в работе/готово”.
3. **Decision log**: принятые решения (стек, auth, БД, деплой, домен, SSL, бэкапы).
4. **Acceptance checklist**: E2E‑проверка + release readiness.

> Канонический шаблон для пунктов 2–4: `templates/project-controls.md`.

**Ритуал конца итерации (обязательный запрос к ассистенту):**
- “что готово / что дальше / блокеры”
- “команды проверки (локально и на сервере)”
- “definition of done” для следующего шага

---

## 4. Figma‑поток (как присылать прототипы)

**Ты присылаешь:**
- 3–10 экранов за раз **одного сценария**
- в сообщении: главный сценарий, что MVP на этих экранах, правила (валидации/роли/ограничения)

**Ассистент возвращает:**
- UI‑спецификацию (компоненты/состояния)
- API‑спеку (эндпоинты + DTO)
- модель БД (сущности/связи)
- порядок реализации (шаги с проверками)

---

## 5. Поддержка SSOT (как обновляем этот файл)

- **Любое новое правило процесса** → добавляем сюда сразу, чтобы не жить “в памяти чата”.
- Если правило устарело — **заменяем**, а не дублируем (сохраняем краткость).
- Если нужно, добавляем мини‑разделы “Примеры запросов” внутри соответствующих секций.
- **Шаблоны артефактов** лежат в `templates/` и считаются частью процесса (обновляем вместе с SSOT).

### 5.1 Примеры запросов по режимам

- **Plan:** “Сделай план: стек X/Y, деплой на VPS с Docker, auth email+password, БД Postgres; дай критерии готовности, риски, чек‑лист проверок.”
- **Agent:** “По плану из §2.1: создай каркас backend (Nest), frontend (Next), docker-compose с Postgres; добавь базовые команды запуска/тестов; покажи диффы.”
- **Debug:** “Тесты падают: timeout в e2e auth/login на CI. Логи прилагаю. Предложи гипотезы, проверки, фикс, как подтвердить.”
- **Ask:** “Посмотри на эти экраны Figma (скрин): распиши Экран → API → Модели → Компоненты → Edge cases; выдели, что идёт в MVP.”

---

## 6. Совместная управленческая роль: System Engineer + Product Manager (Lite)

**Зачем:** ускорять путь к продакшену без потери качества, удерживая **ценность + архитектуру + риски + эксплуатацию** в одном контуре управления.

### 6.1 Принципы (SE+PM Lite)
- **Value-first (PM):** приоритеты, MVP‑границы, критерии “готово”, управление scope.
- **Quality-by-design (SE):** системные границы, NFR, архитектурные решения, риски, эксплуатация.
- **Traceability Lite:** требования → решения → проверки (ссылками, без бюрократии).
- **Change control:** новые идеи проходят через “влияние на MVP/архитектуру/риски/срок”.

### 6.2 Ответственности (что делаем вместе)
- **Сформулировать North Star + MVP + NFR** (см. §3 и E0).
- **Зафиксировать архитектуру и ключевые решения** (E1) и не “дрейфовать” без записи.
- **Обеспечить ранний CI + smoke‑deploy** (E2), чтобы инфраструктурные риски вскрывались сразу.
- **Держать Backlog живым**: приоритеты, зависимости, Definition of Done.
- **Управлять рисками**: выявить → снизить → проверить → зафиксировать (Decision log).
- **Release readiness**: перед релизом пройти acceptance checklist и эксплуатационные пункты (логи/бэкапы/миграции).

### 6.3 Артефакты (SSOT‑связка)
- **Architecture description**: `templates/architecture-description.md`
- **Project controls (Decision log + Backlog + Iteration review + Acceptance checklist)**: `templates/project-controls.md`
- **Figma legend**: `templates/figma-legend.md`

> Правило: изменения процесса сначала отражаем в `project-workflow.md`, затем при необходимости обновляем соответствующий шаблон в `templates/`.

### 6.4 Ритуалы управления (минимально, но регулярно)
- **Start (каждый эпик/итерация):** обновить North Star/MVP‑границы при необходимости, выбрать 1–3 цели итерации, определить DoD.
- **End (каждая итерация):** заполнить iteration review + выполнить команды проверки; обновить Decision log при новых решениях.
- **Развилки:** при выборе из >2 альтернатив — короткий Plan‑разбор и запись решения в Decision log.
